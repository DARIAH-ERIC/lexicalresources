<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>Introduction to XSLT: scenarios and examples</title>
   </head>
   <body>
      <h1>Headwords</h1>
      <h1>Diagnosis</h1>
      <h2>Entries without 
         <gi>form</gi>
      </h2>
      <h2>Entries with a definition not contained within a sense.</h2>
      <h2>Duplicate entries</h2>
      <h2>Different words in entries</h2>
      <h1>Entries</h1>
      
      General introduction to XSLT
      
      An XML application; a recommendation of the W3C: XSL Transformations (XSLT) Version 3.0 W3C Recommendation 8 June
      2017
      Based on XPath: addressing, selecting, functions
      Core principle: Input + XSLT =&gt; Output
      Usual usage: XML + XSLT =&gt; XML (e.g. XHTML)
      Other useful usages: 
      XML + XSLT =&gt; Text (e.g. generation of CSV outputs)
      Text + XSLT =&gt; XML (e.g. structuring of existing text input)
      
      
      
      
      
      Making an XSLT stylesheet work
      
      Baseline XSLT structure
      The following example is a complete and workable stylesheet to generate an HTML output
      from an XML document.
      
      
      
      
      
      Linking an XSLT document to an existing XML document in Oxygen: Associate XSLT/CSS stylesheet (green pin).
      Issues:
      
      The XSLT namespace: http://www.w3.org/1999/XSL/Transform
      xsl:output: importance of method and encoding
      Default XSLT behaviour: traversal of the XML tree structure (from parent to child)
      until text nodes are encountered and send to the output stream
      xsl:template: intercepting the default behaviour
      
      
      
      Intercepting the default behaviour
      The xsl:template element provides a specific behaviour for any node fulfilling the constraint in match
      
      
      
      
      
      
      
      Important: dealing with the namespace of the input document. Two possibilities:
      
      declaring the namespace with a prefix and using the prefix for all TEI elements: 
      
      
      
      
      
      
      
      
      
      
      declaring a default namespace for XPath constructs by means of xpath-default-namespace: 
      
      
      
      
      
      
      
      
      
      
      
      We adopt the latter in the rest of the tutorial.
      Playing with further presentational aspects:
      
      Headwords in bold: 
      
      
      
      
      
      
      
      Examples in italics (Note: use of constraints in XPath): 
      
      
      
      
      
      
      
      Putting parentheses around pronunciations: 
      
      [
      
      ]
      
      
      
      Variant: dealing with cases where the pronunciation is already in square brackets:
      
      
      [
      
      ]
      
      
      
      Logical operators: and and not
      Removing leading and trailing whitespaces with normalize-space()
      String functions in XSLT: start-with() and ends-with()
      
      
      
      Dealing with senses: presenting sense as a new line, numbering senses when they do
      not have a n attribute.
      
      
      
      
      
      
      
      
      
      
      
      -
      
      
      
      Main features:
      
      Using axes: preceding-sibling::*
      Arithmetic functions: count(), +
      Multiple tests using xsl:choose (with xsl:when and xsl:otherwise)
      
      
      
      Intercepting the root element
      Setting up the global structure of the output document and selecting the objects to
      visualise:
      
      
      
      
      
      
      
      
      
      In real life: this is usually the first template to implement.
      
      
      First notions of cherry picking
      Showing the body only:
      
      
      
      Building up a simple HTML head:
      
      
      
      
      
      
      
      Using oXygen to get the appropriate XPath expression.
      
      
      
      Sorting objects by means of xsl:sort
      Using xsl:sort requires two main elements:
      
      A context that selects a group of nodes to be sorted (e.g. xsl:apply-templates)
      A sort key that can be extracted for each node of the group
      
      Sorting all orthographic forms as a header to the output document (e.g. to carry out
      a diagnosis).
      
      
      
      
       - 
      
      
      
      
      Dictionary check-ups
      
      Entries without forms
      
      
      
      XPath and XSLT mechanisms in use:
      
      Complex XML tree traversal with xsl:apply-templates
      Testing the existence of a given child element (Does entry contain form?)
      XPtath function: not()
      
      
      
      Definition not embedded in a sense
      The TEI lex 0 initiative recommends that all definitions (def) are actually part of an encompassing sense
      
      
      
      
      
      Identifying duplicate entries
      Looking for all the different forms in the dictionary and checking those for which
      there exist more than one entry.
      XPath and XSLT mechanisms in use:
      
      XPtah function: distinct-values()
      Creating variables with xsl:variable
      Iterator XSLT construct: xsl:for-each
      Arithmetic operator: count() and &gt;
      Loosing the context node within an iteration (hence the theDictionary variable
      
      
      
      
      
      
      
       - 
      
      
      
      
      
      Different words used in definitions
      XPath and XSLT mechanisms in use:
      
      XPtath iterator: for X in Y return Z with local variables
      XPath tokenise()
      Practical separator attribute on xsl:value-of
      
      
      
      
      
      
      
      
      Complementary remarks
      
      Favour a highly modular XSLT programming style to ensure conciseness and ease of maintenance.
      Therefore, always prefer xsl:apply templates to xsl:for-each when applicable
      When a stylesheet is not working, the main issue is usually a wrongly declared namespace.
      Pay attention to this when implementing an XML2XML scenario
      Take a regular look at the XPath and XSLT quick references (Quick Reference Cards from Mulberry Technologies,
      Inc.): be curious to discover new functions, at least to know they exist.
      
      
      
   </body>
</html>